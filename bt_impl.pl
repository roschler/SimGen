:- module(bt_impl, [
	      bad_thing_happened/0,
	      reset_nodes_for_module/1,
	      set_current_bt_module/0,
	      def_node/4,   % node(+Head, +Oper, +Args, +Children)
	      start_context/3, % start_context(+Root, +Context, +Time)
%	      end_context/1, % end_context(+Context),
	      start_simulation/4, % start_simulation(+StartTime, +TimeUnit, +TickLength, +External)
	      end_simulation/0,
%	      bt_time/1, % get the time of the global clock
%	      bt_context_time/2, % get the time of the context clock
	      check_nodes/0, % check_nodes
	      make_cn/2,
	      emit/1
	 ]).
/** <module> run time support for bt
 *
 * "If you have done something twice, you are likely to do it again."
 *
 * Brian Kernighan and Bob Pike
 *
 * Agent based version
*/
user:file_search_path(nodes, 'nodes/').
user:file_search_path(simgen, '.').

:- use_module(simgen(clocks)).
:- use_module(simgen(valuator)).
:- use_module(nodes(random_selector)).
:- use_module(nodes(pdq)).
:- use_module(nodes(check_guard)).
:- use_module(nodes(wait_guard)).
:- use_module(nodes(set_guard)).
:- use_module(nodes(clear_guard)).
:- use_module(nodes(sequence)).
:- use_module(nodes(try_decorator)).

		 /*******************************
		 * Compilation support          *
		 *******************************/

:- dynamic node_/5.   % node_(Module, Head, Operator, Args, Children)

:- module_transparent set_current_bt_module/0.

%!	set_current_bt_module is det
%
%	module_transparent predicate that
%	records the calling module.
%	def_node/4 uses this info
%
%	Users usually won't call this.
%	It's for the compiler
%
set_current_bt_module :-
	debug(bt(compile, node), 'in set_current_bt_module\n', []),
	context_module(Module),
	nb_setval(current_bt_module, Module).

%!	reset_nodes_for_module(+Module:atom) is det
%
%	reset the nodes for the passed in module
%
%       Users usually won't call this, it's for the compiler
%
reset_nodes_for_module(Module) :-
	retractall(node_(Module, _, _, _, _)).

%! def_node(+Head:atom, +Oper:atom, +Args:args, +Children:list) is det
%
%	Define a node.
%	A _node_ is a cell in an behavior tree
%
%	@arg Head the name of the node, an atom
%	@arg Oper the name of the operation type for the node
%	@arg Args a single item or list of items. Meaning depends on
%	Oper
%	@arg Children a list of
%	@tbd change this to a term_expansion
%
%    Users would usually not call this directly. def_node/4 calls are
%    generated by use_bt
%
def_node(Head, _, _, _) :-
	node_(_, Head, _, _, _),
	gtrace,
	!,
	line_count(current_input, Line),
	debug(error(compile, multiply_defined_node),
	      '~w is multiply defined on line ~d.', [Head, Line]).
def_node(Head, Oper, Args, Children) :-
	\+ node_(_, Head, _, _, _),
	debug(bt(compile, node), 'node ~w ~w ~w ~w~n',
	      [Head, Oper, Args, Children]),
	nb_getval(current_bt_module, Module),
	assertz(node_(Module, Head, Oper, Args, Children)),
	debug(bt(compile, node), 'asserted~n', []).

%!	check_nodes is semidet
%
%	Succeeds if all referenced nodes are defined
%	emits messages if not.
%
%       Called at end of module compilation
%
check_nodes :-
	\+ node_(_, _, _, _, _),
	!.
check_nodes :-
	setof(Node, a_used_node(Node), Used),
	maplist(check_def, Used).

a_used_node(Node) :-
	node_(_, _, _, _, Children),
	member(Node, Children).

check_def(Node) :- node_(_, Node, _, _, _).
check_def(Node) :-
	(   setof(Head, M^O^A^(node_(M, Head, O, A, Children), member(Node, Children)), Heads)
	; Heads = []),
	maplist(print_no_def(Node), Heads).

print_no_def(Node, Head) :-
	format(atom(Msg), 'Node ~w is used in node ~w but is not defined', [Node, Head]),
	print_message(error, error(existance_error(procedure, Node),
					      context(node:Head, Msg))).

		 /*******************************
		 *          User API            *
		 *******************************/

%!     start_simulation(
%! +StartTime:number, +TimeUnit:number, +TickLength:number,
%! +External:term) is det
%
%	run a new simulation
%
%	@arg StartTime time in user units to run the first tick at
%	@arg TimeUnit how long is one user unit in nanos?
%	@arg TickLength how long is a tick in user units?
%	@arg external data for use by event listeners
%
start_simulation(StartTime, TimeUnit, TickLength, External) :-
	abolish_clocks(_),
	clock_units(TimeUnit, TickLength),
	new_clock(simgen, StartTime),
	broadcast(simulation_starting),
	do_ticks(External),
	!.  % make it steadfast

%!	end_simulation is det
%
%	Stop a running simulation at the
%	end of the tick
%
%   Must be called from the simulation thread
%   (usually a message listener)
%
end_simulation :-
	thread_send_message(simgen, end_simulation).

start_context(Root, Context, Time) :-
	thread_send_message(simgen, new_clock(Context, Time)),
	thread_send_message(simgen, start_node(Context-Root)).

		 /*******************************
		 * Support for User API         *
		 *******************************/

		 /*******************************
		 *	   Simulator            *
		 *******************************/

/*
 * See the document agentbased.md that should have come
 * with this file for information about the design of this code.
 */

/*
 *  Queue to send messages into the simulator during simulation
 */
:- initialization (  message_queue_property(_, alias(simgen)),
		     message_queue_destroy(simgen)
		  ;
		     true
		  ),
		  message_queue_create(_, [alias(simgen)]).

/*
Queue to buffer messages to make agent-like behavior
*/

:- initialization (  message_queue_property(_, alias(u)),
		     message_queue_destroy(u)
		  ;
		     true
		  ),
		  message_queue_create(_, [alias(u)]).

det_reset(Goal, Ball, Continuation) :-
	(   reset(Goal, Ball, Continuation)
	->  true
	;   Ball = 0,
	    Continuation = 0
	).

do_ticks(_External) :-
	end_simulation_message_exists.
do_ticks(External) :-
	update_clocks,
	get_clock(simgen, Time),
	% this is for external prolog
	ignore(broadcast_request(tick(External, Time, NewExtern))),
	% this is *from* external prolog
	empty_simgen_queue,
	cycle_values,
	do_tick_start,
	empty_u_queue,
	valuator,
	do_tick_end,
	empty_u_queue,
	broadcast_values,
	show_debug,
	do_ticks(NewExtern).

empty_simgen_queue :-
	thread_get_message(simgen, new_clock(Name, Start), [timeout(0)]),
	!,
	new_clock(Name, Start),
	empty_simgen_queue.
empty_simgen_queue :-
	thread_get_message(simgen, start_node(Context-Root), [timeout(0)]),
	!,
        make_cn(Context-Root, Context-'$none$'),
	empty_simgen_queue.
empty_simgen_queue.

% always fail but report what we're handling
handle_the_ball(    Ball,
		    _Config,
		    _Clocks,
		    _Vals,
		    _OldVals,
		    _QTasks,
		    _QTNT,
		    Context,
		    Node,
		    _Continuation) :-
    debug(bt(ticks, balls), 'handle ball ~w in context ~w node ~w', [Ball, Context, Node]),
    fail.
% I am out of balls for this task
handle_the_ball(    0,
		    Config,
		    Clocks,
		    Vals,
		    OldVals,
		    QTasks,
		    QTNT,
		    _Context,
		    _Node,
		    _) :-
	do_tasks(Config, Clocks, Vals, OldVals, QTasks, QTNT).
% Queue a task for execution this tick
handle_the_ball(    qtask(Task),
		    Config,
		    Clocks,
		    Vals,
		    OldVals,
		    QTasks,
		    QTNT,
		    Context,
		    Node,
		    Continuation) :-
	append(QTasks, [Task], NewTasks),
	with_context(Context, reset(ignore(Continuation), Ball, NewContinuation)),
	handle_the_ball(Ball,
		    Config,
		    Clocks,
		    Vals,
		    OldVals,
		    NewTasks,
		    QTNT,
		    Context,
		    Node,
		    NewContinuation).
% Queue this task to continue next tick
handle_the_ball(    next_tick(NodeContext, NodeName),
		    Config,
		    Clocks,
		    Vals,
		    OldVals,
		    QTasks,
		    QTNT,
		    _Context,
		    _Node,
		    Continuation) :-
	append(QTNT, [task(NodeContext, NodeName, Continuation)], NewQTNT),
	do_tasks(Config, Clocks, Vals, OldVals, QTasks, NewQTNT).
% Queue a task for execution next tick
handle_the_ball(    qtnt(Task),
		    Config,
		    Clocks,
		    Vals,
		    OldVals,
		    QTasks,
		    QTNT,
		    Context,
		    Node,
		    Continuation) :-
	with_context(Context, reset(ignore(Continuation), Ball, NewContinuation)),
	handle_the_ball(Ball,
		    Config,
		    Clocks,
		    Vals,
		    OldVals,
		    QTasks,
		    [Task | QTNT],
		    Context,
		    Node,
		    NewContinuation).
% End the simulation.
handle_the_ball(end_simulation, _, _, _, _, _, _, _, _, _).
% Get the value this tick
% Caller must check value. If it's ground, life is good.
% if not, Must be called again
% til you get grounded value
handle_the_ball(    getval(Name, Val),
		    Config,
		    Clocks,
		    Vals,
		    OldVals,
		    QTasks,
		    QTNT,
		    Context,
		    Node,
		    Continuation) :-
	(   get_the_value(Context, Name, Vals, Val, _),
	    det_reset_in_context(Context, Continuation, Ball, NewContinuation),
	    handle_the_ball(Ball,
		    Config,
		    Clocks,
		    Vals,
		    OldVals,
		    QTasks,
		    QTNT,
		    Context,
		    Node,
		    NewContinuation)
	;
	    append(QTasks, [task(Context, Node, Continuation)], NewQTasks),
	    do_tasks(Config, Clocks, Vals, OldVals, NewQTasks, QTNT)
	).

do_tick_end :-
	broadcast(tick_end).

% Set the value
handle_the_ball(    setval(Name, Val),
		    Config,
		    Clocks,
		    Vals,
		    OldVals,
		    QTasks,
		    QTNT,
		    Context,
		    Node,
		    Continuation) :-
	debug(bt(ticks, vals), 'setval ~w context ~w value ~w',
	      [Name, Context, Val]),
	% if we already have it, we have multiple sources
	(   get_the_value(Context, Name, Vals, _AVal, By),
	    print_message(error, bt_fatal_error(flow_error(multiple_sources), culprit(Node, Context, Name, By)))
	;
	    det_reset_in_context(Context, Continuation, Ball, NewContinuation),
	    handle_the_ball(Ball,
		    Config,
		    Clocks,
		    [val(Name, Context, Node, Val) | Vals],
		    OldVals,
		    QTasks,
		    QTNT,
		    Context,
		    Node,
		    NewContinuation)
	).
% get the clock
%
% clocks are named simgen for the master clock, the context for the
% context clock, and Context-Node-Something for other clocks
%
handle_the_ball(    getclock(Name, Val),
		    Config,
		    Clocks,
		    Vals,
		    OldVals,
		    QTasks,
		    QTNT,
		    Context,
		    Node,
		    Continuation) :-
	(   member(clock(Name, Val), Clocks), !
	;
	    print_message(error, bt_fatal_error(flow_error(no_clock), culprit(Node, Context, Name)))
	),
	det_reset_in_context(Context, Continuation, Ball, NewContinuation),
        handle_the_ball(Ball,
		    Config,
		    Clocks,
		    Vals,
		    OldVals,
		    QTasks,
		    QTNT,
		    Context,
		    Node,
		    NewContinuation).
handle_the_ball(    newclock(Name, Time),
		    Config,
		    Clocks,
		    Vals,
		    OldVals,
		    QTasks,
		    QTNT,
		    Context,
		    Node,
		    Continuation) :-
	(   member(clock(Name, _), Clocks),
	    print_message(error, bt_fatal_error(flow_error(restart_clock), culprit(Node, Context, Node)))
	;
	   true
	),
	det_reset_in_context(Context, Continuation, Ball, NewContinuation),
        handle_the_ball(Ball,
		    Config,
		    [clock(Name, Time) | Clocks],
		    Vals,
		    OldVals,
		    QTasks,
		    QTNT,
		    Context,
		    Node,
		    NewContinuation).

% terminate(Node, Context) - remove all tasks from qtask and
%      qtnt that unify with Node and Context
handle_the_ball(    terminate(Node, Context),
		    Config,
		    Clocks,
		    Vals,
		    OldVals,
		    QTasks,
		    QTNT,
		    Context,
		    Node,
		    Continuation) :-
	    det_reset_in_context(Context, Continuation, Ball, NewContinuation),
	    select(task(Context, Node, _), QTasks, NewQTasks),
	    select(task(Context, Node, _), QTNT, NewQTNT),
	    handle_the_ball(Ball,
		    Config,
		    Clocks,
		    Vals,
		    OldVals,
		    NewQTasks,
		    NewQTNT,
		    Context,
		    Node,
		    NewContinuation).

:- meta_predicate with_node(+, 0), with_events(0).

with_context(Context, Goal) :-
	b_getval(context, OldContext),
	b_setval(context, Context),
	call(Goal),
	b_setval(context, OldContext).

current_context(Context) :-
	b_getval(context, Context).

with_node(Node, Goal) :-
	b_getval(current_node, OldNode),
	b_setval(current_node, Node),
	call(Goal),
	b_setval(current_node, OldNode).

% this isn't working
% because we never return from the call
% probably because cond is never failing
with_events(Goal) :-
	current_context(Context),
	shift(getclock(simgen, Time)),
	shift(getclock(Context, ContextTime)),
	b_getval(current_node, Node),
	debug(bt(ticks,  events), 'start(~w, ~w, ~w, ~w, ~w)',
	      [Time, ContextTime, Context, Node, start]),
	broadcast(text(Time, ContextTime, Context, Node, start)),
	(   call(Goal)
	->   Result = succeed
	;    Result = fail
	),
	debug(bt(ticks,  events), 'text(~w, ~w, ~w, ~w, ~w)',
	      [Time, ContextTime, Context, Node, Result]),
	broadcast(text(Time, ContextTime, Context, Node, Result)),
        (   Result = succeed
	->  true
	;   fail
	).


current_node(Node) :-
	b_getval(current_node, Node).


get_message_tasks([task(Context, Node, Goal) | Rest]) :-
	thread_get_message(simgen, task(Context, Node, Goal), [timeout(0)]),
	get_message_tasks(Rest).
get_message_tasks([]).

end_simulation_message_exists :-
	thread_get_message(simgen, end_simulation, [timeout(0)]).

:- multifile bt_impl:make_cn_impl/3.

make_cn(C-N, CParent-NParent) :-
	node_(_M, N, O, _A, _C),
	make_cn_impl(O, C-N, CParent-NParent).

		 /*******************************
		 * Run Time Library	       *
		 *******************************/

start_context_clock(Context, Time) :-
	shift(newclock(Context, Time)).

run_node(Context, Node) :-
	node_(_M, Node, Op, Args, Children),
	debug(bt(nodes, start_stop), 'node ~w starts', [Node]),
	(   with_context(Context, with_node(Node, with_events(run_node(Op, Args, Children))))
	->   Result = true
	;    Result = fail
	),
	(   Result = true
	->  debug(bt(nodes, start_stop), 'node ~w succeeds', [Node])
	;   debug(bt(nodes, start_stop), 'node ~w fails', [Node])
	),
	(   Result = true
	->  true
	;   fail).

run_node(Node) :-
	current_context(Context),
	run_node(Context, Node).

run_node(~? , Args, Children) :-
	sum_list(Args, Total),
	Select is random_float * Total,
	run_random(Select, Args, Children).
run_node('!' , [FirstTick, OtherTicks, Conds], _) :-
	gtrace,
	eval(FirstTick),
	current_context(Context),
	current_node(Node),
	debug(bt(ticks, next_tick), 'Context ~w node ~w waits for next tick',
	      [Context, Node]),
	shift(next_tick(Context, Node)),
	% AHA! when I get back here, my stack's blown away!
	% The continuation is 'rest of this clause' not
	% 'continuation sandwich', I think, so I need to
	% expand all the with_ things!!!
	debug(bt(ticks, next_tick), 'Context ~w node ~w resumes at next tick',
	      [Context, Node]),
	more_eval(OtherTicks, Conds).

% BUG - more_eval isn't failing or succeeding, it's
% just not
%
% DEBUG
more_eval(Statements, Conds) :-
	shift(getclock(simgen, Clock)),
	debug(bt(ticks, val), 'at time ~w more_eval(~w, ~w)', [Clock,
		   Statements, Conds]),
	fail.
more_eval(Statements, Conds) :-
	eval(Statements),
	conds(Conds),  % first tick always succeeds so do it here
	current_context(Context),
	current_node(Node),
	shift(next_tick(Context, Node)),
	more_eval(Statements, Conds).
more_eval(_, _) :-
	current_context(Context),
	current_node(Node),
	debug(bt(ticks, val),
	      'condition failed node ~w context ~w',
	      [Node, Context]),
	!, fail.

run_random(_Select, _, [Child]) :-
	run_node(Child).
run_random(Select, [A |_], [Child | _]) :-
	Select < A,
	run_node(Child).
run_random(Select, [A |T], [_ | Kids]) :-
	Select >= A,
	NS is Select - A,
	run_random(NS, T, Kids).
run_random(_, [], _) :-
	current_node(Node),
	print_message(warning, bt_nonfatal_error(node_error(no_child_to_run), culprit(Node))).

		 /*******************************
		 * Dev Support
		 *******************************/

% whenever we're in trouble we call this, so there's a convenient place
% to stick a gtrace
bad_thing_happened :-
	true.

show_debug.


:- module(bt_impl, [
	      bad_thing_happened/0,
	      reset_nodes_for_module/1,
	      set_current_bt_module/0,
	      def_node/4,   % node(+Head, +Oper, +Args, +Children)
	      start_context/3, % start_context(+Root, +Context, +Time)
%	      end_context/1, % end_context(+Context),
	      start_simulation/4, % start_simulation(+StartTime, +TimeUnit, +TickLength, +External)
	      end_simulation/0,
%	      bt_time/1, % get the time of the global clock
%	      bt_context_time/2, % get the time of the context clock
	      check_nodes/0, % check_nodes
	      make_cn/2,
	      make_cn_impl/3,
	      emit/1
	 ]).
/** <module> run time support for bt
 *
 * "If you have done something twice, you are likely to do it again."
 *
 * Brian Kernighan and Bob Pike
 *
 * Agent based version
*/

:- use_module(clocks).
:- use_module(valuator).
% TBD put these in a directory
:- use_module(random_selector).
:- use_module(pdq).

		 /*******************************
		 * Compilation support          *
		 *******************************/

:- dynamic node_/5.   % node_(Module, Head, Operator, Args, Children)

:- module_transparent set_current_bt_module/0.

%!	set_current_bt_module is det
%
%	module_transparent predicate that
%	records the calling module.
%	def_node/4 uses this info
%
%	Users usually won't call this.
%	It's for the compiler
%
set_current_bt_module :-
	debug(bt(compile, node), 'in set_current_bt_module\n', []),
	context_module(Module),
	nb_setval(current_bt_module, Module).

%!	reset_nodes_for_module(+Module:atom) is det
%
%	reset the nodes for the passed in module
%
%       Users usually won't call this, it's for the compiler
%
reset_nodes_for_module(Module) :-
	retractall(node_(Module, _, _, _, _)).

%! def_node(+Head:atom, +Oper:atom, +Args:args, +Children:list) is det
%
%	Define a node.
%	A _node_ is a cell in an behavior tree
%
%	@arg Head the name of the node, an atom
%	@arg Oper the name of the operation type for the node
%	@arg Args a single item or list of items. Meaning depends on
%	Oper
%	@arg Children a list of
%	@tbd change this to a term_expansion
%
%    Users would usually not call this directly. def_node/4 calls are
%    generated by use_bt
%
def_node(Head, _, _, _) :-
	node_(_, Head, _, _, _),
	line_count(current_input, Line),
	format(atom(Msg), '~w is multiply defined on line ~d.', [Head, Line]),
	print_message(error, error(permission_error(modify, procedure, Head),
				   context(Head, Msg))).
def_node(Head, Oper, Args, Children) :-
	\+ node_(_, Head, _, _, _),
	debug(bt(compile, node), 'node ~w ~w ~w ~w~n',
	      [Head, Oper, Args, Children]),
	nb_getval(current_bt_module, Module),
	assertz(node_(Module, Head, Oper, Args, Children)),
	debug(bt(compile, node), 'asserted~n', []).

%!	check_nodes is semidet
%
%	Succeeds if all referenced nodes are defined
%	emits messages if not.
%
%       Called at end of module compilation
%
check_nodes :-
	\+ node_(_, _, _, _, _),
	!.
check_nodes :-
	setof(Node, a_used_node(Node), Used),
	maplist(check_def, Used).

a_used_node(Node) :-
	node_(_, _, _, _, Children),
	member(Node, Children).

check_def(Node) :- node_(_, Node, _, _, _).
check_def(Node) :-
	(   setof(Head, M^O^A^(node_(M, Head, O, A, Children), member(Node, Children)), Heads)
	; Heads = []),
	maplist(print_no_def(Node), Heads).

print_no_def(Node, Head) :-
	format(atom(Msg), 'Node ~w is used in node ~w but is not defined', [Node, Head]),
	print_message(error, error(existance_error(procedure, Node),
					      context(node:Head, Msg))).

		 /*******************************
		 *          User API            *
		 *******************************/

%!     start_simulation(
%! +StartTime:number, +TimeUnit:number, +TickLength:number,
%! +External:term) is det
%
%	run a new simulation
%
%	@arg StartTime time in user units to run the first tick at
%	@arg TimeUnit how long is one user unit in nanos?
%	@arg TickLength how long is a tick in user units?
%	@arg external data for use by event listeners
%
start_simulation(StartTime, TimeUnit, TickLength, External) :-
	abolish_clocks(_),
	clock_units(TimeUnit, TickLength),
	new_clock(simgen, StartTime),
	do_ticks(External).

%!	end_simulation is det
%
%	Stop a running simulation at the
%	end of the tick
%
%   Must be called from the simulation thread
%   (usually a message listener)
%
end_simulation :-
	thread_send_message(simgen, end_simulation).

start_context(Root, Context, Time) :-
	thread_send_message(simgen, new_clock(Context, Time)),
	thread_send_message(simgen, start_node(Context-Root)).

		 /*******************************
		 * Support for User API         *
		 *******************************/

		 /*******************************
		 *	   Simulator            *
		 *******************************/

/*
 * See the document agentbased.md that should have come
 * with this file for information about the design of this code.
 */

/*
 *  Queue to send messages into the simulator during simulation
 */
:- initialization (  message_queue_property(_, alias(simgen)),
		     message_queue_destroy(simgen)
		  ;
		     true
		  ),
		  message_queue_create(_, [alias(simgen)]).

/*
Queue to buffer messages to make agent-like behavior
*/

:- initialization (  message_queue_property(_, alias(u)),
		     message_queue_destroy(u)
		  ;
		     true
		  ),
		  message_queue_create(_, [alias(u)]).


do_ticks(_External) :-
	end_simulation_message_exists.
do_ticks(External) :-
	update_clocks,
	get_clock(simgen, Time),
	% this is for external prolog
	ignore(broadcast_request(tick(External, Time, NewExtern))),
	% this is *from* external prolog
	empty_simgen_queue,
	do_tick_start,
	empty_u_queue,
	valuator,
	do_tick_end,
	empty_u_queue,
	show_debug,
	do_ticks(NewExtern).

empty_simgen_queue :-
	thread_get_message(simgen, new_clock(Name, Start), [timeout(0)]),
	!,
	new_clock(Name, Start),
	empty_simgen_queue.
empty_simgen_queue :-
	thread_get_message(simgen, start_node(Context-Root), [timeout(0)]),
	!,
        make_cn(Context-Root, Context-'$none$'),
	empty_simgen_queue.
empty_simgen_queue.

do_tick_start :-
	repeat,
	broadcast_request(tick_start),
	fail.
do_tick_start.

do_tick_end :-
	repeat,
	broadcast_request(tick_end),
	fail.
do_tick_end.

empty_u_queue :-
	thread_get_message(u, Msg, [timeout(0)]),
	!,
	broadcast(Msg),
	empty_u_queue.
empty_u_queue.

end_simulation_message_exists :-
	thread_get_message(simgen, end_simulation, [timeout(0)]).

:- multifile make_cn_impl/3.

make_cn(C-N, CParent-NParent) :-
	node_(_M, N, O, _A, _C),
	make_cn_impl(O, C-N, CParent-NParent).

emit(Msg) :-
	thread_send_message(u, Msg).

		 /*******************************
		 * DONE TO HERE
		 *******************************/


run_node('!' , [FirstTick, OtherTicks, Conds], _) :-
	gtrace,
	eval(FirstTick),
	current_context(Context),
	current_node(Node),
	debug(bt(ticks, next_tick), 'Context ~w node ~w waits for next tick',
	      [Context, Node]),
	shift(next_tick(Context, Node)),
	% AHA! when I get back here, my stack's blown away!
	% The continuation is 'rest of this clause' not
	% 'continuation sandwich', I think, so I need to
	% expand all the with_ things!!!
	debug(bt(ticks, next_tick), 'Context ~w node ~w resumes at next tick',
	      [Context, Node]),
	more_eval(OtherTicks, Conds).

% BUG - more_eval isn't failing or succeeding, it's
% just not
%
% DEBUG
more_eval(Statements, Conds) :-
	shift(getclock(simgen, Clock)),
	debug(bt(ticks, val), 'at time ~w more_eval(~w, ~w)', [Clock,
		   Statements, Conds]),
	fail.
more_eval(Statements, Conds) :-
	eval(Statements),
	conds(Conds),  % first tick always succeeds so do it here
	current_context(Context),
	current_node(Node),
	shift(next_tick(Context, Node)),
	more_eval(Statements, Conds).
more_eval(_, _) :-
	current_context(Context),
	current_node(Node),
	debug(bt(ticks, val),
	      'condition failed node ~w context ~w',
	      [Node, Context]),
	!, fail.


		 /*******************************
		 * Continuous evaluator
		 *******************************/

eval([]).
eval([H | T]) :-
	eval(H),
	eval(T).
eval(':='(LVAL, RVAL)) :-
	eval_rval(lastval, RVAL, Value),
	shift(setval(LVAL, Value)),
	emit_val(LVAL, Value),
	debug(bt(flow, vals), 'set value ~w := ~w', [LVAL, Value]).
eval('='(LVAL, RVAL)) :-
	eval_rval(getval, RVAL, Value),
	shift(setval(LVAL, Value)),
	emit_val(LVAL, Value),
	debug(bt(flow, vals), 'set value ~w = ~w', [LVAL, Value]).

conds(X) :- once(conds_(X)).
conds_([]).
conds_([H | T]) :-
	H =.. [CompareOp, Left, Right],
	eval_rval(ezval, Left, LeftVal),
        eval_rval(ezval, Right, RightVal),
	!,
        Compo =.. [CompareOp, LeftVal, RightVal],
	call_if_avail(Compo, LeftVal, RightVal),
	debug(bt(ticks, cond), 'cond ~w ~w ~w passed', [CompareOp, LeftVal, RightVal]),
	conds(T).
conds_([H | _]) :-
	debug(bt(ticks, cond), 'cond ~w failed', [H]),
	fail.

call_if_avail(_, '$not_avail$', _).
call_if_avail(_, _, '$not_avail$').
call_if_avail(Goal, A, B) :-
	A \= '$not_avail$',
	B \= '$not_avail$',
	call(Goal).

eval_rval(GetFunctor, RVal , Value) :-
	RVal =.. [F, A, B],
	eval_rval(GetFunctor, A, AVal),
	eval_rval(GetFunctor, B, BVal),
	e(F, AVal, BVal, Value).
eval_rval(GetFunctor, -A , Value) :-
	eval_rval(GetFunctor, A, AVal),
	Value is -AVal.
eval_rval(GetFunctor, eval(RVal) , Value) :-
	RVal =.. [F | Args],
	get_functor_ok(GetFunctor, F),
	maplist(eval_rval(GetFunctor), Args, ArgVals),
	do_func(F, ArgVals, Value).
eval_rval(GetFunctor, eval(F), Value) :-
	atom(F),
	get_functor_ok(GetFunctor, F),
	do_func(F, [], Value).
eval_rval(_, const(Val), Val).
% we must call GetFunctor in a loop. This is how we do
% dataflow logic
eval_rval(GetFunctor, var(Name), Val) :-
	Func =.. [GetFunctor, Name, Val],
	shift(Func),
	(   var(Val)
	->  eval_rval(GetFunctor, var(Name), Val)
	;   true
	).

emit_val(LVAL, Value) :-
	current_context(Context),
	shift(getclock(simgen, Time)),
	shift(getclock(Context, ContextTime)),
	broadcast(reading(Time, ContextTime, Context, LVAL, Value)).

% TODO make this do somethin
get_functor_ok(_,_).

e( '+', A, B, C) :- C is A + B.
e( '-', A, B, C) :- C is A - B.
e( '*', A, B, C) :- C is A * B.
e( '/', A, B, C) :- C is A / B.

do_func(levy_flight, [LastVal, Lo, Hi], Val) :-
	map64k(LastVal, Lo, Hi, LastValMapped), % map to range [0-64k)
	levy_flight(LastValMapped, NewValMapped),
	map64k(Val, Lo, Hi, NewValMapped).
do_func(wander, [LastVal, Lo, Hi, Dist], Val) :-
	Bias is 2 * (LastVal - Lo) / (Hi - Lo) ,
	random(R),
	Del is 2 * Dist * R - Dist * Bias,
	Val is min(Hi, max(Lo, LastVal + Del)).
do_func(clock, [], Val) :-
	current_context(Context),
	debug(bt(flow,clock), 'function clock(~w)', [Context]),
	shift(getclock(Context, Val)).

map64k(N, Lo, Hi, Mapped) :-
	ground(Mapped),
	N is Lo + (Hi - Lo) * Mapped / 65536.0 .
map64k(N, Lo, Hi, Mapped) :-
	ground(N),
	Mapped is round((N - Lo) * 65536.0 / (Hi - Lo)).

% compute new mapped value from old mapped value
levy_flight(LastVal, NewVal) :-
	random_between(0, 0xf, BitsToFlip),
	Bit is ((1 << BitsToFlip) >> 1),
	levy_flight(LastVal, NewVal, Bit).

levy_flight(V, V, 0).
levy_flight(LastVal, Val, Bit) :-
	random_between(0,1, Flip),
	(   Flip =:= 0
	->  NewVal is LastVal /\ xor(0xffff , Bit)
	;   NewVal is LastVal \/ Bit
	),
	NewBit is Bit >> 1,
	levy_flight(NewVal, Val, NewBit).

% TODO make good messages
%
%
		 /*******************************
		 * Dev Support
		 *******************************/

% whenever we're in trouble we call this, so there's a convenient place
% to stick a gtrace
bad_thing_happened :-
	true.

show_debug.
